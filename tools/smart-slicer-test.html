<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Tile Slicer - Visual Test</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
        }
        .container { max-width: 1600px; margin: 0 auto; }
        h1 { color: #00d4ff; margin-bottom: 20px; }
        .panel {
            background: #16213e;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        input, button, select {
            padding: 8px 12px;
            background: #0f3460;
            border: 1px solid #e94560;
            border-radius: 4px;
            color: #fff;
        }
        button { cursor: pointer; background: #e94560; }
        button:hover { background: #ff6b6b; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .canvas-container {
            background: #0f3460;
            border-radius: 4px;
            overflow: auto;
            max-height: 500px;
            position: relative;
        }
        canvas { display: block; max-width: 100%; }
        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .stat-box {
            background: #0f3460;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }
        .stat-value { font-size: 20px; color: #00d4ff; font-weight: bold; }
        .stat-label { font-size: 12px; color: #888; }
        .loading { display: none; text-align: center; padding: 40px; }
        .loading.active { display: block; }
        .spinner {
            width: 40px; height: 40px;
            border: 3px solid #0f3460;
            border-top-color: #e94560;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .legend { display: flex; gap: 20px; margin-top: 10px; font-size: 12px; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 20px; height: 20px; border-radius: 2px; }
        .tile-list {
            max-height: 300px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 5px;
        }
        .tile-item {
            background: #0f3460;
            padding: 5px;
            border-radius: 4px;
            text-align: center;
            font-size: 11px;
        }
        .tile-item.sprite { border: 2px solid #f44336; }
        .tile-item canvas { width: 100%; image-rendering: pixelated; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Smart Tile Slicer - 智能瓦片切割可视化</h1>

        <div class="panel">
            <div class="controls">
                <input type="file" id="imageInput" accept="image/*">
                <button id="presetBtn">加载预设 (target_pic_1)</button>
                <select id="detectMode">
                    <option value="auto">自动检测尺寸</option>
                    <option value="manual">手动指定</option>
                </select>
                <input type="number" id="tileWidth" placeholder="宽" value="48" min="8" max="128" style="width:60px">
                <input type="number" id="tileHeight" placeholder="高" value="48" min="8" max="128" style="width:60px">
                <button id="sliceBtn" disabled>开始分析</button>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>分析中...</p>
        </div>

        <div class="grid" id="results" style="display:none">
            <div class="panel">
                <h3>原始图像 + 网格</h3>
                <div class="canvas-container">
                    <canvas id="originalCanvas"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background:#4caf50"></div>
                        <span>背景瓦片</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background:#f44336"></div>
                        <span>精灵/动态对象</span>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>分类结果</h3>
                <div class="canvas-container">
                    <canvas id="classifyCanvas"></canvas>
                </div>
                <div class="stats" id="stats"></div>
            </div>
        </div>

        <div class="panel" id="tilePanel" style="display:none">
            <h3>检测到的精灵 (红色边框)</h3>
            <div class="tile-list" id="spriteList"></div>
        </div>
    </div>

    <script type="module">
        import { SmartTileSlicer } from '../src/tools/smart-tile-slicer/SmartTileSlicer.js';

        let currentImage = null;
        let slicerResult = null;

        document.getElementById('imageInput').addEventListener('change', handleImageUpload);
        document.getElementById('presetBtn').addEventListener('click', loadPreset);
        document.getElementById('sliceBtn').addEventListener('click', startAnalysis);
        document.getElementById('detectMode').addEventListener('change', toggleManualInput);

        function toggleManualInput() {
            const manual = document.getElementById('detectMode').value === 'manual';
            document.getElementById('tileWidth').disabled = !manual;
            document.getElementById('tileHeight').disabled = !manual;
        }

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                currentImage = new Image();
                currentImage.onload = () => {
                    document.getElementById('sliceBtn').disabled = false;
                };
                currentImage.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        async function loadPreset() {
            try {
                const response = await fetch('/resources/target_pic_1.jpeg');
                const blob = await response.blob();
                currentImage = new Image();
                currentImage.onload = () => {
                    document.getElementById('sliceBtn').disabled = false;
                };
                currentImage.src = URL.createObjectURL(blob);
            } catch (err) {
                alert('加载预设失败: ' + err.message);
            }
        }

        async function startAnalysis() {
            if (!currentImage) return;

            const loading = document.getElementById('loading');
            loading.classList.add('active');

            try {
                const mode = document.getElementById('detectMode').value;
                const slicer = new SmartTileSlicer({}, {
                    autoDetectSize: mode === 'auto',
                    expectedTileWidth: mode === 'manual' ? parseInt(document.getElementById('tileWidth').value) : undefined,
                    expectedTileHeight: mode === 'manual' ? parseInt(document.getElementById('tileHeight').value) : undefined,
                    enableSpriteDetection: true,
                    enablePerceptualHash: true
                });

                slicerResult = await slicer.sliceSmart(currentImage);
                displayResults();
            } catch (err) {
                alert('分析失败: ' + err.message);
            } finally {
                loading.classList.remove('active');
            }
        }

        function displayResults() {
            document.getElementById('results').style.display = 'grid';
            document.getElementById('tilePanel').style.display = 'block';

            drawOriginalCanvas();
            drawClassifyCanvas();
            updateStats();
            displaySprites();
        }

        function drawOriginalCanvas() {
            const canvas = document.getElementById('originalCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = currentImage.width;
            canvas.height = currentImage.height;

            ctx.drawImage(currentImage, 0, 0);

            // 绘制网格
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;

            for (let x = 0; x <= slicerResult.cols; x++) {
                ctx.beginPath();
                ctx.moveTo(x * slicerResult.tileWidth, 0);
                ctx.lineTo(x * slicerResult.tileWidth, canvas.height);
                ctx.stroke();
            }

            for (let y = 0; y <= slicerResult.rows; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * slicerResult.tileHeight);
                ctx.lineTo(canvas.width, y * slicerResult.tileHeight);
                ctx.stroke();
            }

            // 标记精灵
            for (const sprite of slicerResult.sprites) {
                ctx.strokeStyle = '#f44336';
                ctx.lineWidth = 3;
                ctx.strokeRect(
                    sprite.pixelX,
                    sprite.pixelY,
                    slicerResult.tileWidth,
                    slicerResult.tileHeight
                );
            }
        }

        function drawClassifyCanvas() {
            const canvas = document.getElementById('classifyCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = slicerResult.cols * 20;
            canvas.height = slicerResult.rows * 20;

            for (let y = 0; y < slicerResult.rows; y++) {
                for (let x = 0; x < slicerResult.cols; x++) {
                    const classification = slicerResult.allClassifications[y][x];
                    ctx.fillStyle = classification.isSprite ? '#f44336' : '#4caf50';
                    ctx.fillRect(x * 20, y * 20, 20, 20);
                }
            }
        }

        function updateStats() {
            const stats = document.getElementById('stats');
            stats.innerHTML = `
                <div class="stat-box">
                    <div class="stat-value">${slicerResult.tileWidth}×${slicerResult.tileHeight}</div>
                    <div class="stat-label">瓦片尺寸</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value">${slicerResult.cols}×${slicerResult.rows}</div>
                    <div class="stat-label">网格</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value">${slicerResult.sprites.length}</div>
                    <div class="stat-label">精灵数</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value">${(slicerResult.confidence * 100).toFixed(0)}%</div>
                    <div class="stat-label">置信度</div>
                </div>
            `;
        }

        function displaySprites() {
            const list = document.getElementById('spriteList');
            list.innerHTML = '';

            // 创建离屏canvas提取瓦片
            const offCanvas = document.createElement('canvas');
            offCanvas.width = currentImage.width;
            offCanvas.height = currentImage.height;
            const offCtx = offCanvas.getContext('2d');
            offCtx.drawImage(currentImage, 0, 0);

            for (const sprite of slicerResult.sprites.slice(0, 50)) {
                const item = document.createElement('div');
                item.className = 'tile-item sprite';

                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');

                // 提取瓦片图像
                const tileData = offCtx.getImageData(
                    sprite.pixelX,
                    sprite.pixelY,
                    slicerResult.tileWidth,
                    slicerResult.tileHeight
                );

                // 创建临时canvas绘制瓦片
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = slicerResult.tileWidth;
                tempCanvas.height = slicerResult.tileHeight;
                tempCanvas.getContext('2d').putImageData(tileData, 0, 0);

                // 绘制到显示canvas
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(tempCanvas, 0, 0, 64, 64);

                item.appendChild(canvas);
                item.innerHTML += `<br>熵: ${sprite.entropy.toFixed(2)}<br>(${sprite.gridX},${sprite.gridY})`;
                list.appendChild(item);
            }
        }
    </script>
</body>
</html>